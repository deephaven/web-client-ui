import React, {
  createContext,
  useCallback,
  useEffect,
  useMemo,
  useRef,
} from 'react';

export type PersistentStateContextType = {
  /**
   *
   * @param id A unique ID generated by the caller.
   *           This identifies the specific state internally and is used to prevent duplicate state
   * @param state The state to persist. Needs to be JSON serializable.
   */
  addState: (
    id: string,
    state: { type: string; version: number; state: unknown }
  ) => void;

  /**
   * Schedules a persistent state update.
   * Will re-render the components that have persistent state to capture their current state.
   */
  scheduleStateUpdate: () => void;

  /**
   * Gets the next item from the initial state iterator.
   * It is expected that each hook will call this once to get its initial state.
   * @param id A unique ID generated by the caller.
   *           This is used to prevent one caller from consuming multiple values from the initial state.
   * @returns The iterator result containing the initial state value (state, version, type) if it exists.
   */
  getInitialState: <S>(
    id: string
  ) => { state: S; version: number; type: string } | undefined;
};

/**
 * Context that holds methods to track the state of all calls to usePersistentState below this provider.
 */
export const PersistentStateContext =
  createContext<PersistentStateContextType | null>(null);
PersistentStateContext.displayName = 'PersistentStateContext';

export type PersistentState<S = unknown> = {
  state: S;
  version: number;
  type: string;
};

export type PersistentStateProviderProps = React.PropsWithChildren<{
  /**
   * The initial state of all calls to usePersistentState.
   * If there are more calls to usePersistentState than there are elements in this array,
   * the state initializer of the usePersistentState call will be used for the rest.
   */
  initialState: PersistentState[];

  /**
   * Called when the state changes.
   * The state is passed as an array of the values of all calls to usePersistentState.
   * The order of the values is the same as the order of the calls to usePersistentState.
   * @param state The state of all calls to usePersistentState.
   */
  onChange: (state: PersistentState[]) => void;
}>;

/**
 * Tracks all calls to the usePersistentState hook below this provider.
 * Keeps track of the state in call order and calls onChange when the state changes.
 */
export function PersistentStateProvider(
  props: PersistentStateProviderProps
): JSX.Element {
  const { initialState, onChange, children } = props;
  const [updateId, setUpdateId] = React.useState(0);

  // We store the previous and next state in a map in case a component calls setState in its render function.
  // This would cause an immediate re-render and usePersistentState may be called multiple times from 1 component
  // before the render finishes and we run the effect to persist the state.
  // JS Maps iterate based on insertion order, so if a component renders multiple times its original position will be maintained
  // while updating its state if it changed in that re-render.
  const persistentData = useRef({
    initial: initialState,
    initialStateMap: new Map<string, PersistentState | undefined>(),
    state: new Map<string, PersistentState>(),
    isTracking: true, // We want to start tracking on the first render
  });

  const addState = useCallback((id: string, state: PersistentState) => {
    if (persistentData.current.isTracking) {
      persistentData.current.state.set(id, state);
    }
  }, []);

  const scheduleStateUpdate = useCallback(() => {
    // Don't trigger again if we are already tracking a render
    if (!persistentData.current.isTracking) {
      persistentData.current.isTracking = true;
      setUpdateId(prev => prev + 1);
    }
  }, []);

  const initialStateIterator = useRef(
    persistentData.current.initial[Symbol.iterator]()
  );

  const getInitialState = useCallback(function getState<S>(
    id: string
  ): PersistentState<S> | undefined {
    // Prevents a component re-rendering multiple times in the same render cycle from taking multiple values from the iterator
    const initialStateForId = persistentData.current.initialStateMap.get(id);
    if (initialStateForId) {
      return initialStateForId as PersistentState<S>;
    }
    const { value } = initialStateIterator.current.next();
    const stateVal = value as PersistentState<S> | undefined;
    persistentData.current.initialStateMap.set(id, stateVal);
    return stateVal;
  }, []);

  useEffect(
    function persistState() {
      if (persistentData.current.isTracking) {
        onChange([...persistentData.current.state.values()]);
        persistentData.current.isTracking = false;
      }
    },
    [updateId, onChange]
  );

  // updateId is used to force consumers to re-render when a state update is scheduled.
  // This way we keep states up-to-date and in order.
  // For example, components with a key being re-ordered would not have new IDs, so we can't just
  // track by ID since we will need the order to rehydrate the state correctly.
  const contextValue = useMemo(() => {
    // Clear tracking here to avoid a React 18 batched updates issue where
    // we cleared the map, then the changed component re-rendered its usePersistentState hook
    // putting the states out of order.
    if (persistentData.current.isTracking) {
      persistentData.current.state = new Map();
    }
    return {
      addState,
      scheduleStateUpdate,
      getInitialState,
      updateId,
    };
  }, [addState, getInitialState, scheduleStateUpdate, updateId]);

  return (
    <PersistentStateContext.Provider value={contextValue}>
      {children}
    </PersistentStateContext.Provider>
  );
}
